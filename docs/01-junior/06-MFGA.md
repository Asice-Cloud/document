#### <span id="MFGA">入门篇其 6 - 让函数再次伟大！</span>

> [!NOTE]
>
> 本章作者：syl
>
> 难度：⭐⭐⭐
>
> 涉及语言：C/C++



##### 函数是将计算机和数学联系起来的桥梁

<h6><img src="../../assets/awesomeface.png" width=25px> 注虽然讲这个有点早了， 但是如果你学习过抽象代数和范畴论的话，就会知道计算机学的函数和数学上的函数本质上就是一模一样的东西。</h6>

**什么是函数**：我们一般将某个可以 **控制何时使用**，可以 **传入参数**，处理后 **存储返回信息** 的代码块称作过程，在高级编程语言中，它也被称为函数。

举个例子：C 语言中函数的结构是这样的：

```c
// 定义
[返回值类型] 函数名(传入参数) {
    //函数体
    return 某个需要返回的值或表达式
}

// 调用
函数名(选择传入某些参数)  //这里()是必需的,调用函数会得到这个函数返回的类型和值
```

来几个术语：

```
调用：在代码中某个地方使用已经定义的函数
传参：将需要的参数传入函数进行处理
函数体：在{}中处理参数的过程
返回：函数处理传入的参数后返回结果
```

下面是 C 语言一个完整的函数定义与调用：

```c
//C
int twice(int i){
    return i*2；
}

int main(){
    int i=1;
    int j=twice(i);
    printf("%d",j);
}
```

<img src="../../assets/bulb.png" width=25px> 你可以把定义过的函数视作一个待使用的变量，可以扔到另一个函数里调用 (称为回调，会在指针章节谈到)，也可以自己调用自己 (称为递归)。但是如何使用变量和函数需要注意它们的生命周期，我们会在后面介绍生命周期这个概念。

```c
//递归的例子：计算第n项斐波那契数列的值
int fibonacci(int n){
    if(n == 1)
        return 1;
    if(n == 2)
        return 1;
    return fibonacci(n-1)+fibonacci(n-2);
}
```



##### 变量的生命周期

1. 变量和函数都遵循先声明后使用的原则，虽然近年来大部分语言支持了部分变量和函数的声明可以在调用的之后，但是出于良好的学习和实践代码开发规范的需求，我们还是推荐先声明再使用的原则。

2. 一般情况下，一个 {} 里的全部内容称作代码块，代码块内部可以定义变量，调用函数等。我们称在某个代码块内部定义的变量为它的局部变量，对应的，在整个代码文件中、在所有 {} 之外定义的就是全局变量。如果 A 代码块在 B 代码块的外部，那么 A 代码块是不能使用 B 代码块的局部变量的。（相当于你的钥匙没法打开隔壁宿舍的门，更进一步的，你也可以认为某些实数域上的法则是不能放到复数域的）。

下面是 C 语言中的一个例子：

```c
//C
int global_number = 1;

void foo(){
    int function_number = 2;
}

int main(){
    //这里是main函数的内部
    int local_number = 3;

    printf("global variable: %d",global_number); //可以使用这个变量
    printf("foo variable: %d",function_number); //出错啦，这是个foo的局部变量
    printf("main variable: %d",local_number); //可以，这是main函数自己的变量
}
```

当然你可以在一个 {} 内写另一个 {}，而更内部的能访问外部的，类似于你能打开自己的宿舍门，也能打开宿舍里面的柜子门。

这边是变量的生命周期的概念之一，{} 结束时，里面的局部变量会被自动销毁，除此之外我们还可以手动控制一些变量的生命周期。

<img src="../../assets/question.png" width=25px> 我们需要介绍几个概念，栈、堆，静态区和常量区。这里它们不是数据结构的栈和堆，而是在内存中的位置。栈用来存储局部变量、函数以及函数的返回值，这一部分我们用户是没法去干涉的。堆则是我们手动分配的内存，可以去做改变。（这一部分我们会在讲到指针的时候讲解，先做了解）。静态区存储全局变量和静态变量，常量区则是存储常量。

顺便提一下，函数也是一个变量，函数名便是指向了它地址的指针。我们会在讲指针时细说。当然众所周知，指针各方面威力都很大，所以我们现代很多语言默认都不提供指针操作了。这里就还是用 C 语言举例子：

```c
//C
//常量
#define PI 3.14

//静态变量
static int zero = 0;

//栈上变量，也称为自动生命周期变量
void test(){
    int tmp=10;
}
int main(int argc, char** argv) {
    int tmp=20;
    test();
}
//在函数 test中声明的 tmp变量只有在test函数被调用时才会分配空间，当函数调用结束后自动释放。
//同时main中tmp变量也局部变量。虽然 test和main函数中有同名的 tmp变量，两者是互不可见的，或者说两者存在于 2 个不同的时空中

//手动分配内存,分配了10个int类型大小的内存给了数组array
int array[10]=(int *)malloc(10*sizeof(int))
```

<img src="../../assets/bulb.png" width=25px> 大家可以自行了解更多相关概念，比如静态变量是什么，语言的内存结构是什么。

<img src="../../assets/question.png" width=25px> 当然我们也有各种方式来管理变量生命周期，比如使用移动等方式。这些我们会在以后学习中遇到。



##### 传参和返回

**在 C 语言中**，我们写一个 swap 函数如下

```c
//C
void swap(int a,int b){
    int tmp = a;
    a = b;
    b = tmp;
}

int main(){
    int a=1;
    int b=2;
    swap(a,b);
    printf("a= %d,b= %d",a,b); //仍然是a=1 b=2;
}
```

<img src="../../assets/bulb.png" width=25px> 我们说调用函数时传入了实际参数，简称实参; 而函数接收的参数是形式参数，简称形参，顾名思义这就是实参的副本，所以对形参动手动脚是不会影响实参的。我们称这种传参方式为值传递。导致值传递没有交换成功的原因，还是之前说的那个生命周期的问题。**要明确的一点是，形参其实就是函数的局部变量**。

```c
//这是古早的c的写法，可以看到形参真正的样子是这样的
void swap(){
    int a;
    int b;
    // ...
}
```

看了这个古早 C 语言，你应该立刻理解了为什么说形参就是实参的副本这个原理。所以如果想要改变实参，方法有两个，一个是用返回值把实参覆盖掉，另一个就是传入实参的地址。后者便是下文的解决方法。

<img src="../../assets/question.png" width=25px> 一个解决方法是使用引用传递，对于变量进行修改，我们不传入变量的值，而是传入变量的地址，我们会在指针章节细说这是怎么实现的，现在可以先做了解：

```c
//C
void swap(int *a,int *b){
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
int main(){
    int a=1,b=2;
    swap(&a,&b);
    printf("a=%d,b=%d",a,b); //现在就是a=2 b=1了
}
```

((((这其实就像我们数学上，先设了一个矩阵是 A, 然后把 A 带入了某个变换中，得到了 B 是变换后的值。但是 A 还是原来的 A.



另一种曲线救国，但是其实本质上还是引用传递（后续章节会解释这是为什么）。

我们之前提过数组这个概念，所以可以这样设计：

``` c
//C
void swap(int arr[]){
    int tmp = arr[0];
    arr[0] = arr[1];
    arr[1] = tmp;
}

int main(){
    int arr[] = {1,2};
    swap(arr);
    printf("a=%d,b=%d",arr[0],arr[1]);
}
```
